![sql](images/sql_4.png)
# SQL для Junior Data Engineers: примеры бизнес задач

Вход в профессию Data Engineer требует не только владения инструментами для построения данных, но и уверенного знания SQL для решения задач различной сложности. Несмотря на то, что многие SQL-запросы могут казаться «аналитическими», на практике именно Data Engineers часто отвечают за их написание и оптимизацию. Ведь аналитикам и специалистам по продукту требуется быстрый и точный доступ к данным для их анализа, а это означает, что DE должны обеспечить доступ к нужным данным и помочь в создании запросов для обработки больших объемов информации.

В этой статье я рассмотрел примеры задач, которые регулярно встречаются в практике Data Engineer. И это тот уровень SQL для Junior, который часто спрашивают на собеседования.

Примеры охватывают анализ активности клиентов, сегментацию по расходам, построение профилей для маркетинговых стратегий и другие кейсы. Эти SQL-запросы — неотъемлемая часть работы DE, позволяя оптимизировать работу с данными и обеспечивать поддержание бизнес-логики на каждом этапе работы.


## Кейс 1: Анализ активности клиентов для маркетинговой стратегии

**Ситуация**: Команда маркетинга хочет узнать, какие клиенты были активны в последний месяц, чтобы сформировать целевые предложения и акционные кампании. Активные клиенты — это те, кто совершал поездки за последние 30 дней.

**Задача**: Получить список уникальных фамилий и имен активных клиентов за последний месяц, чтобы отправить им персонализированные предложения.

**Решение**: Использование подзапроса для фильтрации `client_id`, соответствующих последним поездкам.

```sql
SELECT 
    last_name, 
    first_name
FROM clients
WHERE client_id IN (
    SELECT DISTINCT client_id
    FROM drives
    WHERE start_time >= CURRENT_DATE - INTERVAL '30 days'
);
```
Это позволяет быстро выделить тех, кто активно пользуется услугой, и сосредоточить маркетинговые усилия на актуальной аудитории.

## Кейс 2: Сегментация поездок по стоимости для оптимизации предложений

**Ситуация**: Компания хочет сегментировать клиентов в зависимости от их расходов, чтобы предлагать более выгодные условия клиентам с высоким средним чеком. Клиенты, которые совершают дорогие поездки, могут быть заинтересованы в пакетах премиум-обслуживания.

**Задача**: Классифицировать поездки по категориям "дорогая" и "дешевая" в зависимости от стоимости, а также вывести место начала поездки для последующего анализа.

**Решение**: Использование JOIN и CASE, чтобы автоматически классифицировать поездки по стоимости.

```sql
SELECT 
    c.client_id,
    c.first_name, 
    c.last_name, 
    d.start_location, 
    d.end_location,
    d.fare,
    CASE
        WHEN d.fare > 3000 THEN 'Дорогая'
        ELSE 'Дешевая'
    END AS fare_category
FROM clients AS c
JOIN drives AS d ON c.client_id = d.client_id
ORDER BY d.fare DESC;
```
Этот запрос позволяет сегментировать данные, предоставляя аналитикам и маркетологам данные для точного таргетирования акций.

## Кейс 3: Определение VIP-клиентов для улучшенного сервиса

**Ситуация**: Компания планирует внедрить VIP-программу для клиентов, которые регулярно тратят большие суммы на поездки. Программа позволит улучшить опыт для этих клиентов и увеличить их лояльность.

**Задача**: Найти всех клиентов, чьи суммарные траты на поездки превышают определенную сумму, например, 5000.

**Решение**: Использование группировки и HAVING, чтобы фильтровать клиентов на основе их общих затрат.

```sql
SELECT 
    c.first_name, 
    c.last_name, 
    SUM(d.fare) AS total_fare
FROM clients AS c
JOIN drives AS d ON c.client_id = d.client_id
GROUP BY c.first_name, c.last_name
HAVING SUM(d.fare) > 5000;
```
Таким образом, легко выделяются клиенты, которые приносят компании наибольший доход, и могут быть предложены дополнительные услуги.

## Кейс 4: Логистика — анализ последовательности поездок

**Ситуация**: Логистическая команда компании хочет понять, в каком порядке клиенты чаще всего используют сервис, чтобы оптимизировать маршруты и предложения.

**Задача**: Определить порядок поездок для каждого клиента, отсортировав их по времени. Это может помочь в анализе предпочтений клиентов и планировании маршрутов.

**Решение**: Использование оконной функции ROW_NUMBER() для нумерации поездок каждого клиента по порядку.

```sql
SELECT 
    c.first_name, 
    c.last_name, 
    d.start_location, 
    d.end_location, 
    d.start_time,
    ROW_NUMBER() OVER(PARTITION BY c.client_id ORDER BY d.start_time) AS trip_number
FROM clients AS c
JOIN drives AS d ON c.client_id = d.client_id;
```
Этот запрос помогает строить маршруты для постоянных клиентов и оптимизировать работу водителей.

## Кейс 5: Выделение поездок с высокой стоимостью для анализа ценообразования

**Ситуация**: Команда по ценообразованию хочет видеть поездки, которые стоят дороже среднего, чтобы понять, какие маршруты и условия приводят к более высоким затратам. Это поможет пересмотреть тарифы и оптимизировать ценовую политику.

**Задача**: Найти поездки, стоимость которых выше среднего, и предоставить эти данные для анализа.

**Решение**: Использование подзапроса с AVG, чтобы выбрать поездки выше средней стоимости.

```sql
SELECT 
    d.drive_id, 
    client_id, 
    fare
FROM drives d
WHERE fare > (SELECT AVG(fare) FROM drives);

-- Другой вариант

WITH avg_fare AS (
    SELECT AVG(fare) AS avg_fare
    FROM drives
)
SELECT 
    d.drive_id, 
    client_id, 
    fare
FROM drives d, avg_fare
WHERE d.fare > avg_fare.avg_fare;
```
Этот запрос быстро определяет поездки с высокими затратами, помогая команде по ценообразованию принимать решения.

## Кейс 6: Поиск клиентов с большим количеством поездок для лояльности

Ситуация: Маркетинг планирует программу лояльности для активных клиентов. Необходимо определить клиентов, которые часто пользуются услугами, чтобы предложить им бонусы или скидки.

Задача: Найти клиентов, которые совершили больше поездок, чем среднее количество поездок среди всех клиентов.

Решение: Использование подзапроса и HAVING для вычисления среднего количества поездок и фильтрации клиентов с количеством поездок выше среднего.

```sql
SELECT 
    c.first_name, 
    c.last_name, 
    COUNT(d.drive_id) AS num_of_trips
FROM clients AS c
JOIN drives AS d ON c.client_id = d.client_id
GROUP BY c.first_name, c.last_name
HAVING COUNT(d.drive_id) > (
    SELECT AVG(num_trips) 
    FROM (SELECT client_id, COUNT(drive_id) AS num_trips FROM drives GROUP BY client_id) AS avg_trips
);

-- Вариант с CTE

WITH avg_trips AS (
    SELECT AVG(num_trips) AS avg_num_trips
    FROM (SELECT client_id, COUNT(drive_id) AS num_trips FROM drives GROUP BY client_id) AS trips
)
SELECT 
    c.first_name, 
    c.last_name, 
    COUNT(d.drive_id) AS num_of_trips
FROM clients AS c
JOIN drives AS d ON c.client_id = d.client_id
GROUP BY c.first_name, c.last_name
HAVING COUNT(d.drive_id) > (SELECT avg_num_trips FROM avg_trips);
```
Этот запрос помогает выделить самых активных клиентов, на которых можно направить усилия программы лояльности.

## Кейс 7: Построение профиля клиента для персонализированных предложений

**Ситуация**: Отдел маркетинга хочет построить профили клиентов, чтобы персонализировать предложения. Например, важно знать максимальную и среднюю стоимость поездок клиента, чтобы лучше понимать его привычки.

**Задача**: Получить максимальную стоимость и общую сумму всех поездок каждого клиента.

**Решение**: Использование оконных функций MAX и SUM для агрегирования данных по каждому клиенту.

```sql
SELECT 
    c.first_name, 
    c.last_name,
    MAX(d.fare) AS max_fare,
    SUM(d.fare) AS total_fare
FROM clients AS c
JOIN drives AS d ON c.client_id = d.client_id
GROUP BY c.first_name, c.last_name;
```
Это помогает строить точные профили для каждого клиента и разрабатывать предложения на основе их расходов.

## Кейс 8: Сегментация клиентов по региону и фамилии для точечного маркетинга

**Ситуация**: Отдел маркетинга запускает целевую кампанию в определенном регионе (например, в Москве) и хочет сегментировать клиентов, чтобы отправить предложения только людям с определенной фамилией.

**Задача**: Найти клиентов из Москвы, чьи фамилии начинаются с буквы "А", и получить данные о их поездках.

**Решение**: Использование JOIN с несколькими условиями для фильтрации по местоположению и фамилии.

```sql
SELECT c.first_name, c.last_name, d.start_location, d.end_location, d.fare
FROM clients AS c
JOIN drives AS d ON c.client_id = d.client_id
WHERE d.start_location = 'Москва' AND c.last_name LIKE 'А%';
```
Этот запрос помогает выделить аудиторию для точечного маркетинга, снижая издержки на широкие рассылки и улучшая качество контакта с клиентами.

### Эти кейсы показывают, как SQL-запросы помогают решать реальные бизнес-задачи Data Engineers, повышая эффективность работы с клиентами, логистикой и ценообразованием.
